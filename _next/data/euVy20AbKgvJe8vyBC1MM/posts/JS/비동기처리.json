{"pageProps":{"params":{"id":["JS","비동기처리"]},"data":"<h1 id=\"비동기 처리\"><a class=\"header-anchor\" href=\"#비동기 처리\">#</a>비동기 처리</h1>\n<p>비동기 상태를 처리하는 방법이 여러 가지가 있고, 콜백 지옥에서 부터 Promise 를 이용한 비동기 처리, axios API 와 async / await 를 이용한 방법까지 진화해보도록 하겠습니다.</p>\n<h2 id=\"Promise\"><a class=\"header-anchor\" href=\"#Promise\">#</a>Promise</h2>\n<blockquote>\n<p>비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과값을 나타냅니다.</p>\n<p>수행시간이 걸리는 작업과 그에 대한 콜백함수를 전달해 줌으로써 작업이 완료( resolve ) 되는 상황에서 callback 이 동작하게 됩니다.</p>\n</blockquote>\n<p><code>Promise</code>는 다음 중 하나의 상태를 가집니다.</p>\n<ul>\n<li>대기(<em>pending)</em>:  이행하거나 거부되지 않은 초기 상태.</li>\n<li>이행(<em>fulfilled)</em>: 연산이 성공적으로 완료됨.</li>\n<li>거부(<em>rejected)</em>: 연산이 실패함.</li>\n</ul>\n<h3 id=\"Promise 기본형\"><a class=\"header-anchor\" href=\"#Promise 기본형\">#</a>Promise 기본형</h3>\n<pre><code class=\"language-javascript\">function getDataPromise() {\n    return new Promise(resolve =&gt; {\n        setTimeout(function() {\n            console.log('요청을 보냈습니다')\n            const data = {'data':'some data'} // 데이터 도착\n            resolve(data) // 내가 원하는 작업 시작\n        },1000)\n    })\n}\nlet response = getDataPromise()\nconsole.log(response) // Promise {&lt;pending&gt;} 상태가 출력됩니다.\n\ngetDataPromise()\n    .then(response =&gt; console.log(response)) // 원하는 값인 data를 출력할 수 있습니다\n</code></pre>\n<h3 id=\"resolve, reject\"><a class=\"header-anchor\" href=\"#resolve, reject\">#</a>resolve, reject</h3>\n<pre><code class=\"language-javascript\">function myPromise (url) {\n    return new Promise( (resolve, reject) =&gt; {\n        if (url === 'http') {\n            resolve('HTTP 200 OK')\n        } else {\n            reject('wrong URL')\n        }\n    })\n}\nconst promise1 = myPromise('http')\nconsole.log(promise1) // fulfilled 상태로 'HTTP 200 OK' 의 값이 담겨 있습니다\n\t\t\t\t// Promise {&lt;fulfilled&gt;: &quot;HTTP 200 OK&quot;}\n\nconst promise2 = myPromise('www') // reject가 되면서 Uncaught 에러가 발생하게 됩니다.\nconsole.log(promise2) // rejected 상태로 완료되었고 'wrong URL' 이 담겨있게됩니다.\n\t\t\t\t// Promise {&lt;rejected&gt;: &quot;wrong URL&quot;}\n\npromise1\n\t.then(response =&gt; {\n    \tconsole.log('성공')\n    \tconsole.log(response)\n\t})\n\t.catch(error =&gt; {\n    \tconsole.log('error')\n        console.log(error)\n\t})\n// promise1에 then, catch 를 하게 된다면 then() 의 콜백함수가 작동하게 되고\n// promise2에 then, catch 를 하게 되면 reject이기 때문에 catch() 의 콜백함수가 작동하게 됩니다.\n</code></pre>\n<h2 id=\"fetch &amp; axios\"><a class=\"header-anchor\" href=\"#fetch &amp; axios\">#</a>fetch &amp; axios</h2>\n<ul>\n<li>\n<p>AJAX ( Asynchronous Javascript And XML )</p>\n<blockquote>\n<p>비동기 방식으로 Promise API 를 활용하여 HTTP 통신을 하는 기술이다</p>\n</blockquote>\n</li>\n<li>\n<p>fetch 는 내장 API 로 비동기 네트워크를 보다 편하게 할 수 있다.</p>\n</li>\n<li>\n<p>axios 는 라이브러리로 사용이 되고 cdn 이나 npm 등을 통하여 설치 후에 사용하게 됩니다.</p>\n</li>\n<li>\n<p>여러 가지 예외 처리나 기술이 적용되어있고 fetch와의 다른점들이 있습니다.</p>\n<ul>\n<li>구형 브라우저를 지원한다</li>\n<li>응답 시간 초과를 설정할 수 있다</li>\n<li>CSRF 보호 기능이 내장되어 있다.</li>\n<li>JSON 데이터를 자동으로 변환시켜 준다</li>\n<li>Node.js 환경에서 사용할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"fetch\"><a class=\"header-anchor\" href=\"#fetch\">#</a>fetch</h3>\n<pre><code class=\"language-javascript\">fetch('https://jsonplaceholder.typicode.com/posts/1/')\n    .then(function(response) {\n        return response.json();\n    })\n    .then(data =&gt; {\n        console.log(data)\n    })\n</code></pre>\n<blockquote>\n<p>첫번째 then 에서 response는 HTTP Response이고 실제 JSON 이 아니게 됩니다.</p>\n<p>Response 객체에서 원하는 데이터를 가져오기 위해 .json() 메서드를 사용해 주게 됩니다.</p>\n</blockquote>\n<h2 id=\"axios &amp; chaining\"><a class=\"header-anchor\" href=\"#axios &amp; chaining\">#</a>axios &amp; chaining</h2>\n<pre><code class=\"language-javascript\">const BASE = `http://jsonplaceholder.typicode.com`\n\naxios.get(`${BASE}/posts/1/`)\n    .then(response =&gt; {\n        console.log(response.data.userId) // 1\n        return response.data.userId\n    })\n    .then(userId =&gt; {\n        return axios.get(`${BASE}/users/${userId}/`)\n    })\n    .then(response =&gt; {\n        console.log(response)\n        console.log(response.data.name)\n    })\n</code></pre>\n<ul>\n<li>처음에 1번 posts 의 정보를 가져오는 요청으로 시작하여 then 요청을 따라가 봅시다</li>\n</ul>\n<ol>\n<li>\n<p>첫 then 에서는 response의 결과를 받아 해당 data의 userId 를 반환하게됩니다.</p>\n</li>\n<li>\n<p>두번째 then 함수에서 userId 를 받아 또다른 axios 요청(유저 정보)을 보내는 데 활용할 수 있습니다</p>\n</li>\n<li>\n<p>axios 요청을 받은 후의 결과를 response 로 받게 되고 결과적으로 1번 글을 작성한 유저의 이름을 알게됩니다</p>\n</li>\n</ol>\n<h3 id=\"async / await\"><a class=\"header-anchor\" href=\"#async / await\">#</a>async / await</h3>\n<blockquote>\n<p>async await 를 사용하여 동기적으로 작동하는 것 <code>처럼</code> 보일 수 있습니다.</p>\n<p>async 는 비동기로 작동하는 함수의 앞에 붙여지게 되고,</p>\n<p>await 는 Promise객체 앞에 놓아 pending 상태에서 fulfilled상태로 완료될때까지 대기하게 됩니다.</p>\n</blockquote>\n<pre><code class=\"language-javascript\">async function getUserName(postId) {\n    const posts = await axios.get(`${BASE}/posts/${postId}/`)\n    const userId = posts.data.userId\n    const users = await axios.get(`${BASE}/users/${userId}`)\n    console.log(users.data.name)\n}\n\nfetchPost(1)\n// postId 를 이용하여 요청을 보내 posts를 알아오게 되고\n// 해당 post 의 userId 를 통하여 두번째 요청을 보내서 user 정보를 알아오게 됩니다.\n</code></pre>\n<h2 id=\"try catch\"><a class=\"header-anchor\" href=\"#try catch\">#</a>try catch</h2>\n<blockquote>\n<p>Promise 에서 에러처리를 위해 .catch() 를 사용한 것 처럼</p>\n<p>async await 에서도 에러처리를 하기 위한 방법으로 try ~ catch 를 사용하게 됩니다.</p>\n</blockquote>\n<pre><code class=\"language-javascript\">async function fetchPost(postId) {\n    try {\n      const posts = await axios.get(`${BASE}/posts/${postId}/`)\n      console.log(posts.data)\n    } catch (error) {\n      console.log(error);\n    }\n}\nfetchPost(1)\n</code></pre>\n<ul>\n<li>\n<p>기본적으로 postId 를 이용하여 post를 가져오는 형태를 유지하고 있습니다.</p>\n</li>\n<li>\n<p>하지만 동작하는 과정을 try 로 묶어 주게 되고 아래 catch 처리를 해주게 되면 요청을 보내면서 생기는 에러를 catch() 에서 잡아서 아래의 동작을 수행하게 됩니다.</p>\n</li>\n</ul>\n","anchor":"<li><a class=\"anchor-tag h1_tags\" href=\"#비동기 처리\">비동기 처리</a></li><li><a class=\"anchor-tag h2_tags\" href=\"#Promise\">Promise</a></li><li><a class=\"anchor-tag h3_tags\" href=\"#Promise 기본형\">Promise 기본형</a></li><li><a class=\"anchor-tag h3_tags\" href=\"#resolve, reject\">resolve, reject</a></li><li><a class=\"anchor-tag h2_tags\" href=\"#fetch & axios\">fetch & axios</a></li><li><a class=\"anchor-tag h3_tags\" href=\"#fetch\">fetch</a></li><li><a class=\"anchor-tag h2_tags\" href=\"#axios & chaining\">axios & chaining</a></li><li><a class=\"anchor-tag h3_tags\" href=\"#async / await\">async / await</a></li><li><a class=\"anchor-tag h2_tags\" href=\"#try catch\">try catch</a></li>"},"__N_SSG":true}