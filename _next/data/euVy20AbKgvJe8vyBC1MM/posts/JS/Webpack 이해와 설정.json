{"pageProps":{"params":{"id":["JS","Webpack 이해와 설정"]},"data":"<h1 id=\"Webpack\"><a class=\"header-anchor\" href=\"#Webpack\">#</a>Webpack</h1>\n<p><a href=\"https://npmjs.com/package/webpack\"><img src=\"https://camo.githubusercontent.com/dcf3110e99c354b13ab7d252b5141df6f9c69710b4d1a6c5194089a5c7b82ff1/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f7765627061636b2e737667\" alt=\"npm\"></a></p>\n<h2 id=\"Webpack 을 사용하는 이유\"><a class=\"header-anchor\" href=\"#Webpack 을 사용하는 이유\">#</a>Webpack 을 사용하는 이유</h2>\n<p>작업, 프로젝트를 진행하면서 코드의 재사용성, 유지보수 등을 위하여 모듈, 기능별로 코드를 관리하는 것이 중요하고 편하다고 생각이 될겁니다.</p>\n<p>하나의 개념( 기능이나 컴포넌트 ) 를 하나의 파일에서 작업을 하는 것이 자연스럽고, 클린 코드에 가깝다고 생각하지만…!</p>\n<p>그러기 위하여 각각의 파일을 브라우저에 로딩을 해야하고 그만큼의 네트워크 비용이 발생하는 단점도 존재합니다.</p>\n<p>더군다나, 그 파일은 서로의 스코프를 침범하지 않아야하고 변수 충돌을 위해서 신경써야하고, 순서에 맞게 로딩을 해야하는 번거로움이 있습니다.</p>\n<p>이러한 것들을 해결하기 위하여 여러 의존 관계에 있는 모듈들을 js 파일 하나로 번들링 하게 되는 <code>정적 모듈 번들러</code> Webpack 이 있습니다 !</p>\n<h2 id=\"Install\"><a class=\"header-anchor\" href=\"#Install\">#</a>Install</h2>\n<p>webpack 패키지와 웹팩 터미널 도구인 <code>webpack-cli</code> 를 설치합니다.</p>\n<pre><code class=\"language-bash\">$ npm install -D webpack webpack-cli\n</code></pre>\n<p>설치 후에</p>\n<pre><code class=\"language-bash\">$ node_modules/.bin/webpack --help\n</code></pre>\n<p>명령어를 이용하여 실행가능한 명령어와 사용방법을 확인할 수 있습니다.</p>\n<h2 id=\"webpack 기본 명령어\"><a class=\"header-anchor\" href=\"#webpack 기본 명령어\">#</a>webpack 기본 명령어</h2>\n<ol>\n<li><code>--mode</code> : 실행환경을 선택하여 빌드 할 수 있다</li>\n</ol>\n<ul>\n<li><code>development</code> , <code>production</code>, <code>none</code> 이 있고</li>\n<li>보통 <code>process.env.NODE_ENV</code> 같은 식으로 기본 환경설정 값으로 사용하기도 한다.</li>\n</ul>\n<ol start=\"2\">\n<li><code>--entry</code> : 시작점 경로를 지정하는 옵션이다 가장 밑바탕 기본이 되는 js, ts 를 타겟으로 한다</li>\n<li><code>--o</code> , <code>--output-path</code> :  번들링 결과물이 위치할 path 입니다.</li>\n</ol>\n<pre><code class=\"language-bash\">$ node_modules/.bin/webpack --mode development --entry ./src/app.js -o dist\n</code></pre>\n<ul>\n<li>위의 명령어 대로 입력을 하게 된다면 <code>src/app.js</code>과 거기서 사용되는 모듈등이 <code>dist</code> 폴더에 <code>main.js</code> 로 번들링 됩니다.</li>\n</ul>\n<ol start=\"4\">\n<li><code>--config</code> : 웹팩 설정파일의 경로를 지정할수 있는데 기본 파일명이 <code>webpack.config.js</code> 이다. webpack.config.js 파일을 통하여 설정을 해줄 수 있습니다.</li>\n<li><code>--watch</code> : 번들링하는 파일, 모듈에 변화가 있으면 감지하여 새로 번들링을 해주게 됩니다. 개발을 하면서 편하게 도움이 됩니다.</li>\n</ol>\n<h2 id=\"webpack.config.js\"><a class=\"header-anchor\" href=\"#webpack.config.js\">#</a>webpack.config.js</h2>\n<pre><code class=\"language-js\">const path = require(&quot;path&quot;)\n\nmodule.exports = {\n  mode: &quot;development&quot;,\n  entry: {\n    main: &quot;./src/app.js&quot;,\n  },\n  output: {\n    filename: &quot;[name].js&quot;,\n    path: path.resolve(&quot;./dist&quot;),\n  },\n}\n</code></pre>\n<ul>\n<li>mode, entry 는 기존 명령어와 동일합니다.</li>\n<li>output 에서 filename 은 지정해 줄 수 있지만 <code>[name]</code> 을 사용하게 되면 entry 에서 key 값으로 들어가있는 main으로 filename 이 생성되는 원리입니다.</li>\n<li>output의 path는 절대경로를 사용하기 때문에 <code>path</code> 모듈을 통해서 절대경로를 참조해 줍니다.</li>\n</ul>\n<h2 id=\"npm script 사용\"><a class=\"header-anchor\" href=\"#npm script 사용\">#</a>npm script 사용</h2>\n<ul>\n<li>package.json 을 이용하기 위해서 npm init 을 사용해 주게 됩니다.</li>\n<li>해당 스크립트는 npm run build 와 같은 방식으로 사용할 수 있습니다</li>\n<li>npm run watch 를 하면 변화가 일어날때마다 build 가 됩니다.</li>\n</ul>\n<pre><code class=\"language-json\">{\n  &quot;scripts&quot;: {\n    &quot;build&quot;: &quot;./node_modules/.bin/webpack&quot;,\n    &quot;watch&quot;: &quot;./node_modules/.bin/webpack --watch&quot;\n  }\n}\n</code></pre>\n<blockquote>\n<p>기본적인 작업은 끝났습니다. 이제는 <code>npm run build</code> 명령어로 설정파일에 따라 번들링 하게 됩니다.</p>\n</blockquote>\n<blockquote>\n<p>지금까지는 js 파일에 대하여 번들링을 하는 과정을 거치게 되었습니다.</p>\n<p>추가적으로 필요한 modules 과 plugins 에 대해서 알아보게 될텐데\nwebpack.config.js 와 함께 보면서 공부하는 편이 좋습니다.</p>\n</blockquote>\n<h2 id=\"modules\"><a class=\"header-anchor\" href=\"#modules\">#</a>modules</h2>\n<pre><code class=\"language-bash\">$ npm install css-loader style-loader url-loader\n</code></pre>\n<h3 id=\"1. css-loader\"><a class=\"header-anchor\" href=\"#1. css-loader\">#</a>1. css-loader</h3>\n<ul>\n<li>webpack 에서 <code>.css</code> 파일을 읽어들이기 위해 사용되는 로더</li>\n</ul>\n<h3 id=\"2. style-loader\"><a class=\"header-anchor\" href=\"#2. style-loader\">#</a>2. style-loader</h3>\n<ul>\n<li>HTML 의 header에 style 태그를 이용하여 DOM 에 CSS를 적용해주는 로더</li>\n<li>기본적으로 style-loader, css-loader 를 같이 사용하는 편이다.</li>\n</ul>\n<pre><code class=\"language-js\">  // webpack.config.js\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          // 개발환경에서는 css-loader에 의해 변경된 css를 적용하기 위해 style-loader를 사용합니다\n          // 프로덕션 환경에서는 별도의 CSS파일을 추출하는 플러그인으로 적용하여 다른 loader 를 사용합니다.\n          process.env.NODE_ENV === &quot;production&quot;\n          ? MiniCssExtractPlugin.loader // 프로덕션 환경\n          : &quot;style-loader&quot;, // 개발 환경\n          &quot;css-loader&quot;,\n        ],\n      },\n    ]\n  }\n</code></pre>\n<h3 id=\"3. url-loader\"><a class=\"header-anchor\" href=\"#3. url-loader\">#</a>3. url-loader</h3>\n<ul>\n<li>background-image 등에서 사용되는 파일들을 불러오는데 쓰인다.</li>\n<li>용량에 따라서 설정을 달리 할 수 있는데, limit 으로 설정한 byte 이하의 이미지 등은 base64로 인코딩하여 javascript 문자열로 변경하여 로딩을 하게 되고 크보다 큰 용량은 그냥 넘겨주게 된다.</li>\n</ul>\n<pre><code class=\"language-js\">  // webpack.config.js\n  module: {\n    rules: [\n      {\n        test: /\\.(png|jpg|gif|svg)$/, // png, jpg, gif, svg 확장자로 끝나는 파일들은 url-loader로 처리하겠다는 의미\n        loader: &quot;url-loader&quot;, // 용량이 적은 파일들은 Data URI Scheme을 이용해서 Base64로 인코딩하여 문자열 형태로 소스코드에 넣는 방식을 이용한다.\n        options: {\n          // publicPath: './dist/', // 아까는 index.html 파일이 src 폴더 위에 있었지만 HtmlWebpackPlugin 설치 후에는 src 폴더 안으로 들어갔기 때문에 빌드된 결과물이 dist 폴더안에 index.html이 자동으로 생기므로 앞에 prefix로 ./dist/ 경로를 붙이지 않아도 된다.\n          name: &quot;[name].[ext]?[hash]&quot;,\n          limit: 20000, // 파일 용량 세팅(20[KB]로 세팅함)\n          // 이미지 파일을 처리할 때 20[KB] 미만의 파일들은 url-loader를 이용해서 Base64로 인코딩하여 자바스크립트 문자열로 변환한다.\n          // 만약 20[KB] 이상인 경우 file-loader를 이용하게 된다.\n          // 그래서 20[KB] 이하인 nyancat.jpg는 빌드된 main.js 파일 안에 url로 처리되어 들어간다.\n          // 20[KB] 이상인 bg.png는 file-loader로 처리되어 bg.png 파일이 dist 폴더 안에 들어오게 된다.\n        },\n      },\n    ]\n  }\n</code></pre>\n<h3 id=\"4. babel\"><a class=\"header-anchor\" href=\"#4. babel\">#</a>4. babel</h3>\n<pre><code class=\"language-bash\">$ npm install babel-loader @babel/core @babel/preset-env\n</code></pre>\n<ul>\n<li>각각 브라우저 마다 매년 새롭게 도입되는 ES6+ 의 지원비율이 제각각이다.</li>\n<li>IE 를 비롯한 구형 브라우저에서는 ES6+ 문법이 제대로 작동이 안될 수도 있고, 모듈 로더가 작동이 잘 안될 수도 있다.</li>\n<li>사용자가 그런것들을 고려하면서 코드를 작성하기에 불편함이 많기에 각각의 브라우저의 지원사항에 맞게 맞춰서 모듈 번들러를 사용하여 동작하게 할 수 있다.</li>\n<li>Arrow Function, optional chaining 등을 ES5 이하의 문법으로 번들링해주는 로더이다.</li>\n<li><code>babel.config.js</code> , <code>.babelrc</code> 등의 파일에 설정을 해준다.</li>\n<li>물론 <code>webpack.config.js</code> 에서도 설정해주어야한다.</li>\n</ul>\n<pre><code class=\"language-js\">  // webpack.config.js\n  const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);\n  \n  module: {\n    rules: [\n      {\n        // 다음과 같이 babel-loader로 webpack과 함께 사용하면 훨씬 단순하고 자동화된 프론트엔드 개발환경을 갖출 수 있다.\n        test: /\\.js$/,\n        loader: &quot;babel-loader&quot;,\n        exclude: /node_modules/,\n      },\n    ],\n  }\n</code></pre>\n<pre><code class=\"language-js\">  // babel.config.js\n  const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);\n\n  module.exports = {\n    presets: [\n      ['@babel/preset-env', {\n        targets: {\n          chrome: '79',\n          ie: '11' // IE11에서도 동작하도록 설정\n          // 참고로 IE11에서 async/await 나 generator 구문을 사용하기 위해서는 regenerator-runtime 라이브러리를 추가로 설치해야 한다.\n        },\n        // babel이 변환하지 못하는 코드는 polyfill이라 부르는 코드조각을 불러와 결과물에 로딩해서 해결한다.\n        useBuiltIns: 'usage', // polyfill 사용 여부 설정\n        corejs: {\n          version: 2 // polyfill 버전 지정\n        }\n      }]\n    ]\n  }\n</code></pre>\n<h2 id=\"plugins\"><a class=\"header-anchor\" href=\"#plugins\">#</a>plugins</h2>\n<ul>\n<li>plugin 들은 써드 파티 패키지로 동작하게 됩니다. <code>module</code>을 이용하여 build 하는 과정을 거친 후, 후처리 하는 동안 작동하고, 사용되게 됩니다.</li>\n</ul>\n<h3 id=\"1. HtmlWebpackPlugin\"><a class=\"header-anchor\" href=\"#1. HtmlWebpackPlugin\">#</a>1. HtmlWebpackPlugin</h3>\n<p>기본적으로 <code>Html</code> 파일이 번들링이 안되기 때문에 plugin 으로 처리해 주게 된다.</p>\n<pre><code class=\"language-bash\">$ npm install -D html-webpack-plugin\n</code></pre>\n<p>node 에서 설치 후에 webpack.config.js 설정을 한 후 실행하게 된다.</p>\n<pre><code class=\"language-js\">  // webpack.config.js\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: &quot;./src/index.html&quot;,\n      templateParameters: {\n        env: process.env.NODE_ENV === &quot;development&quot; ? &quot;개발&quot; : &quot;배포&quot;,\n      },\n    }),\n  ]\n</code></pre>\n<blockquote>\n<p>./src/index.html</p>\n</blockquote>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;title&gt;Webpack Test (&lt;%= env %&gt;)&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>위와 같이 예시로</p>\n<ul>\n<li>title을 ejs 문법을 사용하여 작성한 Html 파일을 <code>templateParameters</code> 와 연동시켜서 env 변수값을 이용하여 동적으로 생성할 수 있다.</li>\n<li>또한 기본적으로는 기본적인 로딩 스크립트가 있어야 하지만 Webpack 에서 빌드한 결과물을 자동으로 주입해주기 때문에 제거하였다.</li>\n</ul>\n<h3 id=\"2. mini-css-extract-plugin\"><a class=\"header-anchor\" href=\"#2. mini-css-extract-plugin\">#</a>2. mini-css-extract-plugin</h3>\n<ul>\n<li>스타일시트 코드만 뽑아서 별도의 CSS파일로 만들어 역할에 따라 파일을 분리해 줍니다.</li>\n<li>CSS를 별도 파일로 뽑아내는 플러그인 입니다.</li>\n<li><code>production</code> mode에는 plugin 에 추가해 주고 해당 모드일 때 <code>.css</code> loader 에서도 작동하게 됩니다.</li>\n</ul>\n<pre><code class=\"language-bash\">$ npm install -D mini-css-extract-plugin\n</code></pre>\n<pre><code class=\"language-js\">  // webpack.config.js\n  plugins: [\n    // MiniCssExtractPlugin은 JS에서 CSS 코드를 뽑아내는 것이기 때문에 굳이 development 환경에서는 JS 파일 하나로 빌드하는 것이 조금 더 빠르기 때문에 굳이 이 플러그인을 쓸 필요가 없다.\n    // production 환경에서만 플러그인이 실행되도록 삼항 연산자로 작성하자.\n    ...(process.env.NODE_ENV === &quot;production&quot;\n      ? [new MiniCssExtractPlugin({ filename: &quot;[name].css&quot; })]\n    : []),\n  ]\n</code></pre>\n<h2 id=\"Referrence\"><a class=\"header-anchor\" href=\"#Referrence\">#</a>Referrence</h2>\n<p><a href=\"https://github.com/webpack/webpack#install\">webpack github</a></p>\n<p><a href=\"https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html\">프론트엔드 개발 환경의 의해 : 웹팩</a></p>\n<p><a href=\"https://kschoi.github.io/webpack/webpack-basic/\">webpack 기본 이해하기</a></p>\n<p><a href=\"https://poiemaweb.com/es6-babel-webpack-1\">babel</a></p>\n<p><a href=\"https://github.com/wally-wally/Frontend_Development_Environment\">Wally-wally</a></p>\n","anchor":"<li><a class=\"anchor-tag h1_tags\" href=\"#Webpack\">Webpack</a></li><li><a class=\"anchor-tag h2_tags\" href=\"#Webpack 을 사용하는 이유\">Webpack 을 사용하는 이유</a></li><li><a class=\"anchor-tag h2_tags\" href=\"#Install\">Install</a></li><li><a class=\"anchor-tag h2_tags\" href=\"#webpack 기본 명령어\">webpack 기본 명령어</a></li><li><a class=\"anchor-tag h2_tags\" href=\"#webpack.config.js\">webpack.config.js</a></li><li><a class=\"anchor-tag h2_tags\" href=\"#npm script 사용\">npm script 사용</a></li><li><a class=\"anchor-tag h2_tags\" href=\"#modules\">modules</a></li><li><a class=\"anchor-tag h3_tags\" href=\"#1. css-loader\">1. css-loader</a></li><li><a class=\"anchor-tag h3_tags\" href=\"#2. style-loader\">2. style-loader</a></li><li><a class=\"anchor-tag h3_tags\" href=\"#3. url-loader\">3. url-loader</a></li><li><a class=\"anchor-tag h3_tags\" href=\"#4. babel\">4. babel</a></li><li><a class=\"anchor-tag h2_tags\" href=\"#plugins\">plugins</a></li><li><a class=\"anchor-tag h3_tags\" href=\"#1. HtmlWebpackPlugin\">1. HtmlWebpackPlugin</a></li><li><a class=\"anchor-tag h3_tags\" href=\"#2. mini-css-extract-plugin\">2. mini-css-extract-plugin</a></li><li><a class=\"anchor-tag h2_tags\" href=\"#Referrence\">Referrence</a></li>"},"__N_SSG":true}