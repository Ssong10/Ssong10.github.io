{"pageProps":{"params":{"id":"Infinite Scroll - 1"},"code":{"html":"<div id=\"app\"></div>\n<div class=\"footer\"></div>","js":"const $app = document.querySelector('#app')\nconst $footer = document.querySelector('.footer')\n\nconst getList = (count) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      const data = Array.from({length:5}).map((_,idx)=>{\n        const id = (count*5)+idx+1\n        return {id, data: `${id}번째 게시글입니다`}\n      })\n      resolve(data)\n    },1000)\n  })\n}\n\nconst renderItem = ({id, data}) => {\n  const item = document.createElement('li')\n  item.innerHTML = `\n    <div class=\"item-id\">${id}</div>\n    <div class=\"item-data\">${data}</div>\n  `\n  return item\n}\nlet count = 0\nconst fetchMore = async () => {\n  $footer.classList.add(\"loading\");\n  const list = await getList(count ++)\n  const frag = document.createDocumentFragment()\n  list.forEach(item=> {\n    frag.appendChild(renderItem(item))\n  })\n  $app.appendChild(frag)\n  $footer.classList.remove(\"loading\");\n}\n\nconst onScroll = (e) => {\n  const {clientHeight,scrollTop,scrollHeight} = e.target.scrollingElement;\n  if (clientHeight + scrollTop === scrollHeight) {\n    fetchMore()\n  }\n}\n\nfetchMore()\nwindow.addEventListener('scroll',onScroll)","css":".footer {\n  height : 50px;\n  line-height: 50px;\n  text-align:center;\n}\n\n#app li {\n  display:flex;\n  margin: 10px;\n  border:1px solid black;\n  height : 20vh;\n  text-align :center;\n  line-height: 20vh\n}\n.item-id {\n  border-right: 1px solid black;\n  width : 20%;\n}\n.item-data {\n  width : 80%;\n}\n\n.loading:after {\n  content: \"... 로딩중 ...\";\n}"},"description":"<h2 id=\"Base Function\"><a class=\"header-anchor\" href=\"#Base Function\">#</a>Base Function</h2>\n<ul>\n<li>\n<p>getList</p>\n<ul>\n<li>5개의 게시글을 a비동기적으로 불러오게 되는 함수</li>\n</ul>\n</li>\n<li>\n<p>renderItem</p>\n<ul>\n<li>하나의 게시글을 DOM 요소로 변경하는 함수</li>\n</ul>\n</li>\n<li>\n<p>fetchMore</p>\n<ul>\n<li>\n<p>$footer 에 loading 을 해준후</p>\n</li>\n<li>\n<p>비동기로 list를 불러옴</p>\n</li>\n<li>\n<p>documentFragment 를 이용하여 $app 요소까지 부착하게 되는 작업</p>\n</li>\n<li>\n<p>loading 표시를 제거해줌</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Main Function\"><a class=\"header-anchor\" href=\"#Main Function\">#</a>Main Function</h2>\n<ul>\n<li>기본적으로 window에 scroll시에 onScroll 을 작동하게 합니다.</li>\n<li>clientHeight 는 element의 내부 높이입니다.\n<ul>\n<li>내부 여백(padding) 을 포함하고,  수평 스크롤바의 높이, 경계선 외부 여백(margin)을 포합하지 않습니다.</li>\n</ul>\n</li>\n<li>scrollTop 은 element 최상단과 보여지는 컨텐츠와의 거리를 의미합니다.\n<ul>\n<li>세로 스크롤가 없다면 scrollTop 은 항상 0이 됩니다</li>\n</ul>\n</li>\n<li>ScrollHeight 는 보이지 않는 부분까지 전체의 높이를 나타냅니다</li>\n<li>결론적으로 스크롤이 제일 바닥으로 내려온 상태가 되면 clientHeight + scrollTop = ScrollHeight 임으로 게시글을 5개 더 불러오게 됩니다.</li>\n</ul>\n<h2 id=\"Issue\"><a class=\"header-anchor\" href=\"#Issue\">#</a>Issue</h2>\n<ul>\n<li>\n<p>scroll 이 발생할때 마다 onScroll이 동작하고 계산을 하게 됩니다.</p>\n<ul>\n<li>이벤트의 발생 횟수를 줄이는 방법을 생각해봅니다</li>\n<li><a href=\"/component/throttle%20&amp;%20debounce\">디바운스와 쓰로틀링</a></li>\n</ul>\n</li>\n<li>\n<p>최적화된 Web API 인 Intersection Observer 를 사용하여 개선할 수 있습니다.</p>\n<ul>\n<li>\n<p>타겟 요소와 상위요소 또는 최상의 document의 사이의 intersection내의 변화를 관찰합니다</p>\n</li>\n<li>\n<p><a href=\"/component/Infinite%20Scroll%20-%202\">Infinite Scroll - 2</a></p>\n</li>\n</ul>\n</li>\n</ul>\n"},"__N_SSG":true}