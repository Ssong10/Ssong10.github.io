{"pageProps":{"params":{"id":["JS","동기&비동기"]},"data":"<h2>동기, 비동기</h2>\n<ul>\n<li><code>Synchronous </code> 동기 : 요청을 보낸 후 해당 요청의 응답을 받아야 다음 동작을 실행하는 방식</li>\n<li><code>Asynchronous</code> 비동기 : 요청을 보낸 후 응답과 관계없이 다음 동작을 실행하는 방식</li>\n</ul>\n<p>자바스크립트에서 CPU의 계산에 의해서 <code>즉시</code> 처리가 가능한 대부분의 코드는 동기적으로 작동하게 됩니다.</p>\n<p>또한 계산식이 복잡해서 CPU 가 계산하는데 시간이 많이 걸리더라도 동기적으로 작동하게 됩니다.</p>\n<p>하지만 !</p>\n<ul>\n<li>사용자의 요청에 의해 특정 시간이 경과되기 전까지 함수의 실행을 보류하는 상황( <code>SetTimeout</code>, <code>setInterval</code> )</li>\n<li>사용자의 직접적인 개입이 있을때 비로소 함수를 실행하도록 대기하거나 (<code>addEventListener</code> )</li>\n<li>웹 브라우저 자체가 아닌 별도의 대상에 요청을 하고 그에 대한 응답을 받고나서 어떤 함수를 실행하는 작업( <code>XMLHttpRequest</code> 기반의 <code>Fetch</code>, <code>Axios</code>)</li>\n</ul>\n<p>를 통틀어 요청, 실행 대기, 보류 와 관련된 코드는 비동기적 코드입니다.</p>\n<p>현대 자바스크립트에서 복잡도에 따라 비동기적 코드의 비중이 높아졌고, callback 함수를 익명함수로 전당하는 과정을 반복하면서 들여쓰기가 반복되는 상황인 <code>callback 지옥</code> 이라는 말도 생기게 되었습니다.</p>\n<p>이러한 <code>비동기 처리</code> 과정의 다양한 방법을 차례대로 살펴보겠습니다.</p>\n<h2>Synchronous 동기</h2>\n<pre><code class=\"language-javascript\">function getData() {\n    const data = {'data': 'some data'}\n    return data\n}\n\nlet response = getData()\nconsole.log(response) // {'data': 'some data'}\n</code></pre>\n<blockquote>\n<p>즉각적인 데이터를 return 해주게 됨으로 원하는 response 를 바로 얻을 수 있습니다.</p>\n</blockquote>\n<h2>Asynchronous 비동기 ( setTimeout )</h2>\n<pre><code class=\"language-javascript\">function getData() {\n    let data\n    setTimeout(function() {\n        console.log('요청을 보냈습니다')\n        data = {'data': 'some data'}\n    }, 1000 )\n    return data\n}\nlet response1 = getData()\nconsole.log(response1)\n// undefined - setTimeout 전에 출력\n// (1000ms later ... )\n// 요청을 보냈습니다\n</code></pre>\n<blockquote>\n<p>1000ms 의 대기시간 후에 data 값이 할당되게 되는데 기다리지 않고 할당되지않은 data가 return 됩니다.</p>\n</blockquote>\n<h2>CallBack function</h2>\n<pre><code class=\"language-javascript\">function getDatacallback(callback){\n    setTimeout(function() {\n        const data = {'data':'some data'} // 데이터 도착\n        callback(data)  // 내가 원하는 작업 시작\n    },1000)\n}\n// 함수 호출, 인자로 함수를 넘겨주는데 그게 출력하는 작업\ngetDatacallback(function(data) {\n    console.log(data)\n})\n</code></pre>\n<blockquote>\n<p>getDatacallback 함수에 data를 출력하는 함수를 callback 함수로 담아서 실행시키게 됩니다.</p>\n<p>그러면 setTimeout 내에서 동작이 이루어 진 후 넘겨주었던 callback 함수에 data를 담아서 실행하게 됩니다.</p>\n</blockquote>\n<h2>promise</h2>\n<pre><code class=\"language-javascript\">function getDataPromise() {\n    return new Promise(resolve =&gt; {\n        setTimeout(function() {\n            const data = {'data':'some data'}\n            resolve(data) // 내가 원하는 작업 시작\n        },1000)\n    })\n}\nlet response3 = getDataPromise()\nconsole.log(response3) // Promise {&lt;pending&gt;}\n\n// 함수 실행 후 then 으로 resolve 함수를 요청할 수 있습니다.\nresponse3.then(response =&gt; console.log(response))\n\ngetDataPromise()\n    .then(response =&gt; console.log(response))\n</code></pre>\n<blockquote>\n<p>비동기처리를 하기 위한 promise API 입니다.</p>\n<p>기본적으로 Promise 객체는 해당 비동기 작업이 끝나게 되면 resolve 함수를 호출하는 방식으로 동작하게 됩니다.</p>\n</blockquote>\n<h2>async / await</h2>\n<pre><code class=\"language-javascript\">function getDataPromise() {\n    return new Promise(resolve =&gt; {\n        setTimeout(function() {\n            const data = {'data':'some data'} // 데이터 도착\n            resolve(data) // 내가 원하는 작업 시작\n        },1000)\n    })\n}\n\nasync function printData() {\n    const data = await getDataPromise()\n    console.log(data)\n}\nprintData()\n</code></pre>\n<blockquote>\n<p>기본적으로 Promise로 구성이 되어있고, fetch, axios 도 물론 사용할 수 있습니다.</p>\n<p>함수 앞에 async 를 이용하여 비동기처리를 할 수 있게 해주고 비동기 함수에 대해서 await 를 통하여 동작시켜주면 getDataPromise 가 동작할때까지 대기를 한 후에 그 다음 동작이 이루어 지게 됩니다.</p>\n<p>비동기 작업의 동기적 표현을 가능하게 해주어 가독성도 뛰어나면서 작성도 간편한 코드입니다.</p>\n</blockquote>\n<h2>Promise, async/await 에 대하여</h2>\n<ul>\n<li>요청받은 데이터를 이용하여 또 다른 요청을 보내는 경우 ( chaining )</li>\n<li>잘못된 값이나 오류의 처리 과정 ( reject , .catch, try catch )</li>\n<li>axios 와  async / await</li>\n</ul>\n<p>위 과정들에 대하여 좀 더 자세히 정리 후에 포스팅 ( <a href=\"/posts/JS/%EB%B9%84%EB%8F%99%EA%B8%B0%EC%B2%98%EB%A6%AC\">비동기 처리</a> )하겠습니다.</p>\n"},"__N_SSG":true}