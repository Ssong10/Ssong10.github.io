<!DOCTYPE html><html><head><link href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap" rel="stylesheet"/><script async="" src="https://kit.fontawesome.com/17820a52a0.js" crossorigin="anonymous"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Ssong10 | 동기&amp;비동기</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/b7aff589bc3f251c5423.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b7aff589bc3f251c5423.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-3462db42ddf64824c665.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9d524150d48315f49e80.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.0d3242e40eb08521ee3c.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-d6b9adca8a08a181a345.js" as="script"/><link rel="preload" href="/_next/static/chunks/fac50134203cbc545d54cf72a9b94a4ba28f5ae7.ff2a065ed04022de0792.js" as="script"/><link rel="preload" href="/_next/static/chunks/3c054efa82999c49f598079c6742f61697ff1d2b.626d3ab021131eea828e.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5B...id%5D-11788b8a639362193f16.js" as="script"/></head><body><div id="__next"><header id="nav"><i class="side-button fas fa-bars"></i><span class="main-title">Ssong10</span><span class="mobile-title">[ JS ] 동기%26비동기</span><div class="nav-links"><div class="nav-sub mobile-home"><span>Ssong10</span></div><div class="nav-sub"><span class="">OS</span><div class="nav-items-wrap"><div class="nav-item-list"><div class="nav-item "><a href="/posts/OS/Operation System"><span>Operation System</span></a></div><div class="nav-item "><a href="/posts/OS/OOP"><span>OOP</span></a></div><div class="nav-item "><a href="/posts/OS/프로세스&amp;스레드"><span>프로세스&amp;스레드</span></a></div><div class="nav-item "><a href="/posts/OS/멀티프로세스&amp;스레드"><span>멀티프로세스&amp;스레드</span></a></div><div class="nav-item "><a href="/posts/OS/HTTP"><span>HTTP</span></a></div><div class="nav-item "><a href="/posts/OS/Protocol"><span>Protocol</span></a></div></div></div></div><div class="nav-sub"><span class="active">JS</span><div class="nav-items-wrap"><div class="nav-item-list"><div class="nav-item "><a href="/posts/JS/기본"><span>기본</span></a></div><div class="nav-item "><a href="/posts/JS/명령형과 선언형"><span>명령형과 선언형</span></a></div><div class="nav-item "><a href="/posts/JS/React Hook 구현"><span>React Hook 구현</span></a></div><div class="nav-item "><a href="/posts/JS/동기&amp;비동기"><span>동기&amp;비동기</span></a></div><div class="nav-item "><a href="/posts/JS/비동기처리"><span>비동기처리</span></a></div><div class="nav-item "><a href="/posts/JS/Webpack 이해와 설정"><span>Webpack 이해와 설정</span></a></div></div></div></div><div class="nav-sub"><span class="">HTML</span><div class="nav-items-wrap"><div class="nav-item-list"><div class="nav-item "><a href="/posts/HTML/브라우저 렌더링"><span>브라우저 렌더링</span></a></div><div class="nav-item "><a href="/posts/HTML/Reflow &amp; Repaint"><span>Reflow &amp; Repaint</span></a></div></div></div></div><div class="nav-sub"><span class="">etc</span><div class="nav-items-wrap"><div class="nav-item-list"><div class="nav-item "><a href="/posts/etc/git"><span>git</span></a></div><div class="nav-item "><a href="/posts/etc/입출력"><span>입출력</span></a></div><div class="nav-item "><a href="/posts/etc/DataBase"><span>DataBase</span></a></div><div class="nav-item "><a href="/posts/etc/DeadLock"><span>DeadLock</span></a></div></div></div></div><div class="nav-sub"><span class="">component</span><div class="nav-items-wrap"><div class="nav-item-list"><div class="nav-item "><a href="/component/loading"><span>loading</span></a></div><div class="nav-item "><a href="/component/loading2"><span>loading2</span></a></div><div class="nav-item "><a href="/component/modal"><span>modal</span></a></div><div class="nav-item "><a href="/component/slide"><span>slide</span></a></div><div class="nav-item "><a href="/component/throttle &amp; debounce"><span>throttle &amp; debounce</span></a></div><div class="nav-item "><a href="/component/Infinite Scroll - 1"><span>Infinite Scroll - 1</span></a></div><div class="nav-item "><a href="/component/Infinite Scroll - 2"><span>Infinite Scroll - 2</span></a></div></div></div></div></div></header><section class="side-bar"><p><span class="side-bar-title">동기&amp;비동기</span></p><ul class="anchor-list"><li><a class="anchor-tag h2_tags" href="#동기, 비동기">동기, 비동기</a></li><li><a class="anchor-tag h2_tags" href="#Synchronous 동기">Synchronous 동기</a></li><li><a class="anchor-tag h2_tags" href="#Asynchronous 비동기 ( setTimeout )">Asynchronous 비동기 ( setTimeout )</a></li><li><a class="anchor-tag h2_tags" href="#CallBack function">CallBack function</a></li><li><a class="anchor-tag h2_tags" href="#promise">promise</a></li><li><a class="anchor-tag h2_tags" href="#async / await">async / await</a></li><li><a class="anchor-tag h2_tags" href="#Promise, async/await 에 대하여">Promise, async/await 에 대하여</a></li></ul></section><main class="container"><div class="markdown"><h2 id="동기, 비동기"><a class="header-anchor" href="#동기, 비동기">#</a>동기, 비동기</h2>
<ul>
<li><code>Synchronous </code> 동기 : 요청을 보낸 후 해당 요청의 응답을 받아야 다음 동작을 실행하는 방식</li>
<li><code>Asynchronous</code> 비동기 : 요청을 보낸 후 응답과 관계없이 다음 동작을 실행하는 방식</li>
</ul>
<p>자바스크립트에서 CPU의 계산에 의해서 <code>즉시</code> 처리가 가능한 대부분의 코드는 동기적으로 작동하게 됩니다.</p>
<p>또한 계산식이 복잡해서 CPU 가 계산하는데 시간이 많이 걸리더라도 동기적으로 작동하게 됩니다.</p>
<p>하지만 !</p>
<ul>
<li>사용자의 요청에 의해 특정 시간이 경과되기 전까지 함수의 실행을 보류하는 상황( <code>SetTimeout</code>, <code>setInterval</code> )</li>
<li>사용자의 직접적인 개입이 있을때 비로소 함수를 실행하도록 대기하거나 (<code>addEventListener</code> )</li>
<li>웹 브라우저 자체가 아닌 별도의 대상에 요청을 하고 그에 대한 응답을 받고나서 어떤 함수를 실행하는 작업( <code>XMLHttpRequest</code> 기반의 <code>Fetch</code>, <code>Axios</code>)</li>
</ul>
<p>를 통틀어 요청, 실행 대기, 보류 와 관련된 코드는 비동기적 코드입니다.</p>
<p>현대 자바스크립트에서 복잡도에 따라 비동기적 코드의 비중이 높아졌고, callback 함수를 익명함수로 전당하는 과정을 반복하면서 들여쓰기가 반복되는 상황인 <code>callback 지옥</code> 이라는 말도 생기게 되었습니다.</p>
<p>이러한 <code>비동기 처리</code> 과정의 다양한 방법을 차례대로 살펴보겠습니다.</p>
<h2 id="Synchronous 동기"><a class="header-anchor" href="#Synchronous 동기">#</a>Synchronous 동기</h2>
<pre><code class="language-javascript">function getData() {
    const data = {'data': 'some data'}
    return data
}

let response = getData()
console.log(response) // {'data': 'some data'}
</code></pre>
<blockquote>
<p>즉각적인 데이터를 return 해주게 됨으로 원하는 response 를 바로 얻을 수 있습니다.</p>
</blockquote>
<h2 id="Asynchronous 비동기 ( setTimeout )"><a class="header-anchor" href="#Asynchronous 비동기 ( setTimeout )">#</a>Asynchronous 비동기 ( setTimeout )</h2>
<pre><code class="language-javascript">function getData() {
    let data
    setTimeout(function() {
        console.log('요청을 보냈습니다')
        data = {'data': 'some data'}
    }, 1000 )
    return data
}
let response1 = getData()
console.log(response1)
// undefined - setTimeout 전에 출력
// (1000ms later ... )
// 요청을 보냈습니다
</code></pre>
<blockquote>
<p>1000ms 의 대기시간 후에 data 값이 할당되게 되는데 기다리지 않고 할당되지않은 data가 return 됩니다.</p>
</blockquote>
<h2 id="CallBack function"><a class="header-anchor" href="#CallBack function">#</a>CallBack function</h2>
<pre><code class="language-javascript">function getDatacallback(callback){
    setTimeout(function() {
        const data = {'data':'some data'} // 데이터 도착
        callback(data)  // 내가 원하는 작업 시작
    },1000)
}
// 함수 호출, 인자로 함수를 넘겨주는데 그게 출력하는 작업
getDatacallback(function(data) {
    console.log(data)
})
</code></pre>
<blockquote>
<p>getDatacallback 함수에 data를 출력하는 함수를 callback 함수로 담아서 실행시키게 됩니다.</p>
<p>그러면 setTimeout 내에서 동작이 이루어 진 후 넘겨주었던 callback 함수에 data를 담아서 실행하게 됩니다.</p>
</blockquote>
<h2 id="promise"><a class="header-anchor" href="#promise">#</a>promise</h2>
<pre><code class="language-javascript">function getDataPromise() {
    return new Promise(resolve =&gt; {
        setTimeout(function() {
            const data = {'data':'some data'}
            resolve(data) // 내가 원하는 작업 시작
        },1000)
    })
}
let response3 = getDataPromise()
console.log(response3) // Promise {&lt;pending&gt;}

// 함수 실행 후 then 으로 resolve 함수를 요청할 수 있습니다.
response3.then(response =&gt; console.log(response))

getDataPromise()
    .then(response =&gt; console.log(response))
</code></pre>
<blockquote>
<p>비동기처리를 하기 위한 promise API 입니다.</p>
<p>기본적으로 Promise 객체는 해당 비동기 작업이 끝나게 되면 resolve 함수를 호출하는 방식으로 동작하게 됩니다.</p>
</blockquote>
<h2 id="async / await"><a class="header-anchor" href="#async / await">#</a>async / await</h2>
<pre><code class="language-javascript">function getDataPromise() {
    return new Promise(resolve =&gt; {
        setTimeout(function() {
            const data = {'data':'some data'} // 데이터 도착
            resolve(data) // 내가 원하는 작업 시작
        },1000)
    })
}

async function printData() {
    const data = await getDataPromise()
    console.log(data)
}
printData()
</code></pre>
<blockquote>
<p>기본적으로 Promise로 구성이 되어있고, fetch, axios 도 물론 사용할 수 있습니다.</p>
<p>함수 앞에 async 를 이용하여 비동기처리를 할 수 있게 해주고 비동기 함수에 대해서 await 를 통하여 동작시켜주면 getDataPromise 가 동작할때까지 대기를 한 후에 그 다음 동작이 이루어 지게 됩니다.</p>
<p>비동기 작업의 동기적 표현을 가능하게 해주어 가독성도 뛰어나면서 작성도 간편한 코드입니다.</p>
</blockquote>
<h2 id="Promise, async/await 에 대하여"><a class="header-anchor" href="#Promise, async/await 에 대하여">#</a>Promise, async/await 에 대하여</h2>
<ul>
<li>요청받은 데이터를 이용하여 또 다른 요청을 보내는 경우 ( chaining )</li>
<li>잘못된 값이나 오류의 처리 과정 ( reject , .catch, try catch )</li>
<li>axios 와  async / await</li>
</ul>
<p>위 과정들에 대하여 좀 더 자세히 정리 후에 포스팅 ( <a href="/posts/JS/%EB%B9%84%EB%8F%99%EA%B8%B0%EC%B2%98%EB%A6%AC">비동기 처리</a> )하겠습니다.</p>
</div></main><footer><div class="links"><a target="_blank" href="https://github.com/ssong10"><i class="fab fa-github"></i></a><a target="_blank" href="https://www.instagram.com/2_seung10/"><i class="fab fa-instagram"></i></a></div><div><small>Ssong10</small></div><div><small>leesy1403@naver.com</small></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"params":{"id":["JS","동기\u0026비동기"]},"data":"\u003ch2 id=\"동기, 비동기\"\u003e\u003ca class=\"header-anchor\" href=\"#동기, 비동기\"\u003e#\u003c/a\u003e동기, 비동기\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eSynchronous \u003c/code\u003e 동기 : 요청을 보낸 후 해당 요청의 응답을 받아야 다음 동작을 실행하는 방식\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAsynchronous\u003c/code\u003e 비동기 : 요청을 보낸 후 응답과 관계없이 다음 동작을 실행하는 방식\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e자바스크립트에서 CPU의 계산에 의해서 \u003ccode\u003e즉시\u003c/code\u003e 처리가 가능한 대부분의 코드는 동기적으로 작동하게 됩니다.\u003c/p\u003e\n\u003cp\u003e또한 계산식이 복잡해서 CPU 가 계산하는데 시간이 많이 걸리더라도 동기적으로 작동하게 됩니다.\u003c/p\u003e\n\u003cp\u003e하지만 !\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용자의 요청에 의해 특정 시간이 경과되기 전까지 함수의 실행을 보류하는 상황( \u003ccode\u003eSetTimeout\u003c/code\u003e, \u003ccode\u003esetInterval\u003c/code\u003e )\u003c/li\u003e\n\u003cli\u003e사용자의 직접적인 개입이 있을때 비로소 함수를 실행하도록 대기하거나 (\u003ccode\u003eaddEventListener\u003c/code\u003e )\u003c/li\u003e\n\u003cli\u003e웹 브라우저 자체가 아닌 별도의 대상에 요청을 하고 그에 대한 응답을 받고나서 어떤 함수를 실행하는 작업( \u003ccode\u003eXMLHttpRequest\u003c/code\u003e 기반의 \u003ccode\u003eFetch\u003c/code\u003e, \u003ccode\u003eAxios\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e를 통틀어 요청, 실행 대기, 보류 와 관련된 코드는 비동기적 코드입니다.\u003c/p\u003e\n\u003cp\u003e현대 자바스크립트에서 복잡도에 따라 비동기적 코드의 비중이 높아졌고, callback 함수를 익명함수로 전당하는 과정을 반복하면서 들여쓰기가 반복되는 상황인 \u003ccode\u003ecallback 지옥\u003c/code\u003e 이라는 말도 생기게 되었습니다.\u003c/p\u003e\n\u003cp\u003e이러한 \u003ccode\u003e비동기 처리\u003c/code\u003e 과정의 다양한 방법을 차례대로 살펴보겠습니다.\u003c/p\u003e\n\u003ch2 id=\"Synchronous 동기\"\u003e\u003ca class=\"header-anchor\" href=\"#Synchronous 동기\"\u003e#\u003c/a\u003eSynchronous 동기\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction getData() {\n    const data = {'data': 'some data'}\n    return data\n}\n\nlet response = getData()\nconsole.log(response) // {'data': 'some data'}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e즉각적인 데이터를 return 해주게 됨으로 원하는 response 를 바로 얻을 수 있습니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"Asynchronous 비동기 ( setTimeout )\"\u003e\u003ca class=\"header-anchor\" href=\"#Asynchronous 비동기 ( setTimeout )\"\u003e#\u003c/a\u003eAsynchronous 비동기 ( setTimeout )\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction getData() {\n    let data\n    setTimeout(function() {\n        console.log('요청을 보냈습니다')\n        data = {'data': 'some data'}\n    }, 1000 )\n    return data\n}\nlet response1 = getData()\nconsole.log(response1)\n// undefined - setTimeout 전에 출력\n// (1000ms later ... )\n// 요청을 보냈습니다\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e1000ms 의 대기시간 후에 data 값이 할당되게 되는데 기다리지 않고 할당되지않은 data가 return 됩니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"CallBack function\"\u003e\u003ca class=\"header-anchor\" href=\"#CallBack function\"\u003e#\u003c/a\u003eCallBack function\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction getDatacallback(callback){\n    setTimeout(function() {\n        const data = {'data':'some data'} // 데이터 도착\n        callback(data)  // 내가 원하는 작업 시작\n    },1000)\n}\n// 함수 호출, 인자로 함수를 넘겨주는데 그게 출력하는 작업\ngetDatacallback(function(data) {\n    console.log(data)\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003egetDatacallback 함수에 data를 출력하는 함수를 callback 함수로 담아서 실행시키게 됩니다.\u003c/p\u003e\n\u003cp\u003e그러면 setTimeout 내에서 동작이 이루어 진 후 넘겨주었던 callback 함수에 data를 담아서 실행하게 됩니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"promise\"\u003e\u003ca class=\"header-anchor\" href=\"#promise\"\u003e#\u003c/a\u003epromise\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction getDataPromise() {\n    return new Promise(resolve =\u0026gt; {\n        setTimeout(function() {\n            const data = {'data':'some data'}\n            resolve(data) // 내가 원하는 작업 시작\n        },1000)\n    })\n}\nlet response3 = getDataPromise()\nconsole.log(response3) // Promise {\u0026lt;pending\u0026gt;}\n\n// 함수 실행 후 then 으로 resolve 함수를 요청할 수 있습니다.\nresponse3.then(response =\u0026gt; console.log(response))\n\ngetDataPromise()\n    .then(response =\u0026gt; console.log(response))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e비동기처리를 하기 위한 promise API 입니다.\u003c/p\u003e\n\u003cp\u003e기본적으로 Promise 객체는 해당 비동기 작업이 끝나게 되면 resolve 함수를 호출하는 방식으로 동작하게 됩니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"async / await\"\u003e\u003ca class=\"header-anchor\" href=\"#async / await\"\u003e#\u003c/a\u003easync / await\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction getDataPromise() {\n    return new Promise(resolve =\u0026gt; {\n        setTimeout(function() {\n            const data = {'data':'some data'} // 데이터 도착\n            resolve(data) // 내가 원하는 작업 시작\n        },1000)\n    })\n}\n\nasync function printData() {\n    const data = await getDataPromise()\n    console.log(data)\n}\nprintData()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e기본적으로 Promise로 구성이 되어있고, fetch, axios 도 물론 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e함수 앞에 async 를 이용하여 비동기처리를 할 수 있게 해주고 비동기 함수에 대해서 await 를 통하여 동작시켜주면 getDataPromise 가 동작할때까지 대기를 한 후에 그 다음 동작이 이루어 지게 됩니다.\u003c/p\u003e\n\u003cp\u003e비동기 작업의 동기적 표현을 가능하게 해주어 가독성도 뛰어나면서 작성도 간편한 코드입니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"Promise, async/await 에 대하여\"\u003e\u003ca class=\"header-anchor\" href=\"#Promise, async/await 에 대하여\"\u003e#\u003c/a\u003ePromise, async/await 에 대하여\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e요청받은 데이터를 이용하여 또 다른 요청을 보내는 경우 ( chaining )\u003c/li\u003e\n\u003cli\u003e잘못된 값이나 오류의 처리 과정 ( reject , .catch, try catch )\u003c/li\u003e\n\u003cli\u003eaxios 와  async / await\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위 과정들에 대하여 좀 더 자세히 정리 후에 포스팅 ( \u003ca href=\"/posts/JS/%EB%B9%84%EB%8F%99%EA%B8%B0%EC%B2%98%EB%A6%AC\"\u003e비동기 처리\u003c/a\u003e )하겠습니다.\u003c/p\u003e\n","anchor":"\u003cli\u003e\u003ca class=\"anchor-tag h2_tags\" href=\"#동기, 비동기\"\u003e동기, 비동기\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca class=\"anchor-tag h2_tags\" href=\"#Synchronous 동기\"\u003eSynchronous 동기\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca class=\"anchor-tag h2_tags\" href=\"#Asynchronous 비동기 ( setTimeout )\"\u003eAsynchronous 비동기 ( setTimeout )\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca class=\"anchor-tag h2_tags\" href=\"#CallBack function\"\u003eCallBack function\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca class=\"anchor-tag h2_tags\" href=\"#promise\"\u003epromise\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca class=\"anchor-tag h2_tags\" href=\"#async / await\"\u003easync / await\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca class=\"anchor-tag h2_tags\" href=\"#Promise, async/await 에 대하여\"\u003ePromise, async/await 에 대하여\u003c/a\u003e\u003c/li\u003e"},"__N_SSG":true},"page":"/posts/[...id]","query":{"id":["JS","동기\u0026비동기"]},"buildId":"euVy20AbKgvJe8vyBC1MM","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-040103c5c51c5268569e.js"></script><script src="/_next/static/chunks/main-3462db42ddf64824c665.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.9d524150d48315f49e80.js" async=""></script><script src="/_next/static/chunks/commons.0d3242e40eb08521ee3c.js" async=""></script><script src="/_next/static/chunks/pages/_app-d6b9adca8a08a181a345.js" async=""></script><script src="/_next/static/chunks/fac50134203cbc545d54cf72a9b94a4ba28f5ae7.ff2a065ed04022de0792.js" async=""></script><script src="/_next/static/chunks/3c054efa82999c49f598079c6742f61697ff1d2b.626d3ab021131eea828e.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5B...id%5D-11788b8a639362193f16.js" async=""></script><script src="/_next/static/euVy20AbKgvJe8vyBC1MM/_buildManifest.js" async=""></script><script src="/_next/static/euVy20AbKgvJe8vyBC1MM/_ssgManifest.js" async=""></script></body></html>